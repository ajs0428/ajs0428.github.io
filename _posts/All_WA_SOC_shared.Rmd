---
title: "SOC controls across Washington"
author: "Anthony Stewart"
date: "`r Sys.Date()`"
output:
  html_document:
    df_print: paged
---

```{css, echo=FALSE}
pre {
  max-height: 300px;
  overflow-y: auto;
}
```

```{r setup, include=FALSE}
library(formatR)
knitr::opts_chunk$set(echo = TRUE, fig.align = "center", fig.show = "hold", time_it = TRUE, dpi = 75)
knitr::opts_chunk$set(tidy.opts = list(width.cutoff = 60), tidy = TRUE)
knitr::opts_knit$set(root.dir = '/Users/Anthony/OneDrive - UW/University of Washington/Data and Modeling/')
library(rgl)
library(terra)
library(lme4)
library(MASS)
library(mgcv)
library(lmerTest)
library(MuMIn)
library(RLRsim)
library(terra)
library(spatialEco)
library(sf)
library(mapview)
library(tidyr)
library(tidyverse)
library(car)
library(ggplot2)
library(sjPlot)
library(sjstats)
library(DHARMa)
library(ggeffects)
library(merTools)
library(glmnet)
library(stats)
library(ggcorrplot)
library(RColorBrewer)
library(cowplot)
library(webshot)
library(kableExtra)
library(caret)
library(pdp)
library(vip)
library(formatR)

knitr::knit_hooks$set(webgl = hook_webgl)
rgl::setupKnitr(autoprint = TRUE)
```

```{r include=FALSE}

# Quick R^2 function
r.sq <- function(y,y.fitted){
    res <- y-y.fitted
    1-sum(res^2)/sum((y-mean(y))^2)
}
```

### Introduction

Mapping soil organic carbon (SOC) as a function climatic, topographic, and geologic factors across spatial extents is key for identifying vulnerable SOC stocks. Yet, large, vulnerable SOC stocks are contained in the organic soils of wetlands and can occur in close proximity to non-wetland soils but are controlled and function differently due to saturated soil conditions. Thus, wetland SOC is often omitted or underrepresented in SOC mapping and modeling making it difficult to assess controls compared to non-wetland soil types. Here, we use geospatial data and SOC stocks from 481 soil horizons in 96 pedons in both wetlands and non-wetlands across three ecoregion study areas of the Pacific Northwest to assess climatic, geologic, and topographic controls on SOC. 

### Hypotheses

1.  WIP is a significant predictor of SOC stock

2.  WIP interaction with climate (Precip & Temp) is a significant predictor of SOC stock

3.  Geology is a significant predictor of SOC stock

### Data
This dataset has observations of SOC% and SOC stock for 96 locations in Washington state. There are geospatial covariates as well that are used to build models to predict SOC% and/or SOC stock

Please note that columns for `field_texture`, `field_texture_binned`, and `redox` are not complete

```{r}
wa_dat <- read.csv("SOIL CARBON/ANALYSIS/All_WA_horizons_spec_geoage.csv")
str(wa_dat)
```

Investigating covariate predictors using correlation plots

```{r}
# Look for high corr values with SOC stock
wa_dat_num <- wa_dat |> select(carbon_perc,
                               carbon_stock_g_cm2,
                               depth_cm,
                               Precip, 
                               Temp,
                               NDYI,
                               NDVI,
                               MNDWI,
                               EVI,
                               SCI,
                               WIP) |> as.matrix()

ggcorrplot(cor(wa_dat_num), method = "square", type = "full", lab = T, lab_size = 2)

```

There is weak correlation between `carbon_stock_g_cm2` and the selected covariates. In a first pass to investigate models

First investigate distribution of carbon stock values

```{r fig.align='center'}
columns_to_exclude <- c("carbon_perc", "carbon_stock_g_cm2") 

wa_dat_scale <- wa_dat |> 
    mutate(across(
        where(is.numeric) & !all_of(columns_to_exclude),
                  ~case_when(TRUE ~ scale(.))))

# wa_dat$depth_cm <- scale(wa_dat$depth_cm) #rescale depth 
# wa_dat$Precip <- scale(wa_dat$Precip) #rescale depth 
# wa_dat$Temp <- scale(wa_dat$Temp) #rescale depth 

hist(wa_dat_scale$carbon_perc) #not of interest but taking a look 


hist(wa_dat_scale$carbon_stock_g_cm2)

```

Now build models using log transformed carbon stock data. We need to specify that `sample_ID` is a random effect because of the multiple samples at one location. `depth` can be a random slope to adjust model based on how it is affected by depth. We could use a Generalized Linear Model or a Generalized Linear Mixed Model here too but they often fail to converge. I am starting with the log-transformed linear mixed model first to test the hypotheses



```{r}
mod1 <- lmer(log(carbon_stock_g_cm2) ~ 
                 WIP*Precip*Temp +  MNDWI + NDVI + NDYI + (GEOLOGIC_AGE)+
                 (1+(depth_cm)|sample_ID), data = wa_dat_scale, REML = F)
# No interactions
mod2 <-lmer(log(carbon_stock_g_cm2) ~ 
                WIP+Precip+Temp +  MNDWI + NDVI + NDYI + (GEOLOGIC_AGE)+
                 (1+(depth_cm)|sample_ID), data = wa_dat_scale, REML = F)
#No spectral
mod3 <- lmer(log(carbon_stock_g_cm2) ~ 
                 WIP*Precip*Temp + (GEOLOGIC_AGE)+
                 (1+(depth_cm)|sample_ID), data = wa_dat_scale, REML = F)
#No geology
mod4 <- lmer(log(carbon_stock_g_cm2) ~ 
                 WIP*Precip*Temp +  MNDWI + NDVI + NDYI + 
                 (1+(depth_cm)|sample_ID), data = wa_dat_scale, REML = F)
#No WIP w/ interaction
mod5 <- lmer(log(carbon_stock_g_cm2) ~ 
                 Precip*Temp +  MNDWI + NDVI + NDYI + (GEOLOGIC_AGE)+
                 (1+(depth_cm)|sample_ID), data = wa_dat_scale, REML = F)
#No WIP w/o interaction
mod6 <- lmer(log(carbon_stock_g_cm2) ~ 
                 Precip+Temp + MNDWI + NDVI + NDYI + (GEOLOGIC_AGE)+
                 (1+(depth_cm)|sample_ID), data = wa_dat_scale, REML = F)
#No climate
mod7 <- lmer(log(carbon_stock_g_cm2) ~ 
                 WIP+  MNDWI + NDVI + NDYI + (GEOLOGIC_AGE)+
                 (1+(depth_cm)|sample_ID), data = wa_dat_scale, REML = F)
#No climate No spectral
mod8 <- lmer(log(carbon_stock_g_cm2) ~ 
                 WIP + (GEOLOGIC_AGE)+
                 (1+(depth_cm)|sample_ID), data = wa_dat_scale, REML = F)
#Just WIP
mod9 <- lmer(log(carbon_stock_g_cm2) ~ 
                 WIP + 
                 (1+(depth_cm)|sample_ID), data = wa_dat_scale, REML = F)

```

Pairwise comparisons between the top, global model and the rest

```{r}
anova(mod1, mod2) #Not significant
anova(mod1, mod3) #Not Significant
anova(mod2, mod3) #
anova(mod1, mod4) #Significant
anova(mod1, mod5) #Significant
anova(mod1, mod6) #Significant
anova(mod1, mod7) #Significant
anova(mod1, mod8) #Significant
anova(mod1, mod9) #Significant

```
From the ANOVAs it looks like the most complex model including all predictors is the best. But it may contain predictors that are intercorrelated (Looking at the spectral metrics). I'm going to pare down the metrics a bit here and compare

```{r}
#No MNDWI
mod2.1 <- lmer(log(carbon_stock_g_cm2) ~ 
                 WIP+Precip+Temp + NDVI + NDYI + (GEOLOGIC_AGE)+
                 (1+(depth_cm)|sample_ID), data = wa_dat_scale, REML = F)
#No MNDWI, No NDVI
mod2.2 <- lmer(log(carbon_stock_g_cm2) ~ 
                 WIP+Precip+Temp + NDYI + (GEOLOGIC_AGE)+
                 (1+(depth_cm)|sample_ID), data = wa_dat_scale, REML = F)
#No NDYI, No NDVI
mod2.3 <- lmer(log(carbon_stock_g_cm2) ~ 
                 WIP+Precip+Temp + MNDWI + (GEOLOGIC_AGE)+
                 (1+(depth_cm)|sample_ID), data = wa_dat_scale, REML = F)
#No NDYI, No MNDWI
mod2.4 <- lmer(log(carbon_stock_g_cm2) ~ 
                 WIP+Precip+Temp + NDVI + (GEOLOGIC_AGE)+
                 (1+(depth_cm)|sample_ID), data = wa_dat_scale, REML = F)
#No NDVI
mod2.5 <- lmer(log(carbon_stock_g_cm2) ~ 
                 WIP+Precip+Temp + NDYI + MNDWI + (GEOLOGIC_AGE)+
                 (1+(depth_cm)|sample_ID), data = wa_dat_scale, REML = F)
#No NDYI
mod2.6 <- lmer(log(carbon_stock_g_cm2) ~ 
                 WIP+Precip+Temp + NDVI + MNDWI + (GEOLOGIC_AGE)+
                 (1+(depth_cm)|sample_ID), data = wa_dat_scale, REML = F)
```

```{r}
anova(mod2, mod2.1) #Not Significant
anova(mod2, mod2.2) #Not Significant
anova(mod2, mod2.3) #Not Significant
anova(mod2, mod2.4) #Not Significant
anova(mod2, mod2.5) #Not Significant
anova(mod2, mod2.6) #Not Significant

```
Model 2.2 and 2.3 are the lowest AIC and not significantly different from the fit in Model 2. The choice is either between MNDWI or NDYI. For this, I want to see if WIP interacts with these variables. 

```{r}
#No MNDWI, No NDVI
mod2.2.1 <- lmer(log(carbon_stock_g_cm2) ~ 
                 Precip+Temp + WIP:NDYI + (GEOLOGIC_AGE)+
                 (1+(depth_cm)|sample_ID), data = wa_dat_scale, REML = F)
#No NDYI, No NDVI
mod2.3.1 <- lmer(log(carbon_stock_g_cm2) ~ 
                 Precip+Temp + WIP:MNDWI + (GEOLOGIC_AGE)+
                 (1+(depth_cm)|sample_ID), data = wa_dat_scale, REML = F)
```

```{r}
anova(mod2.3, mod2.2.1)
anova(mod2.3, mod2.3.1)
anova(mod2.2.1, mod2.3.1)
```

Doesn't look like there are any significant interactions that improve model fit

Now we can look at the table of all models and compare AICs

```{r 'model list and table', message=FALSE, echo=FALSE}
mod_list <- list(mod1, mod2, mod3, mod4, mod5, mod6, mod7, mod8, mod9, mod2.1, mod2.2,
                 mod2.3, mod2.4, mod2.5, mod2.6, mod2.2.1, mod2.3.1)
mod_names <- c("mod1", "mod2", "mod3", "mod4", "mod5", "mod6", "mod7", "mod8", "mod9",
               "mod2.1", "mod2.2", "mod2.3", "mod2.4", "mod2.5", "mod2.6", "mod2.2.1", "mod2.3.1")


mod_AIC = matrix(nrow = length(mod_list), ncol =3)


for (i in 1:length(mod_list)) {
    mod_AIC[i,1] <- round(AIC(mod_list[[i]]), 2)
    mod_AIC[i,2] <- paste0(formula(mod_list[[i]]))[3]
    mod_AIC[i,3] <- mod_names[i]
}
    
delta_AIC <- as.data.frame(cbind(mod_AIC))
delta_AIC$delta <- as.numeric(delta_AIC$V1) -  min(as.numeric(delta_AIC$V1))
names(delta_AIC) <- c("AIC", "formula", "name", "delta")



#tab_model(mod_list, show.aic = T, show.aicc = T, dv.labels = mod_names)
```

```{r message=FALSE, echo=FALSE, out.width="75%"}
library(kableExtra)
delta_AIC |>
  kbl() |>
  kable_classic_2("hover", full_width = F)
```

Looks like the best model according to AIC is the `mod2.2` or `mod2.3` which do not include any interactions. The model $R^2$ is `r r.sq(log(wa_dat$carbon_stock_g_cm2), fitted(mod2.2))` and the fit looks fairly good on a log-based plot

```{r, echo=FALSE, warning=FALSE, message=FALSE}
library(RColorBrewer)
ggplot(wa_dat_scale, aes(y = (fitted(mod2.2)), x = log(carbon_stock_g_cm2))) +
    geom_jitter(color='black', 
               aes(fill = (wa_dat$WIP*100), shape = as.factor(GEOLOGIC_AGE)),
               size = 3, stroke = 0.9, alpha = 0.7) +
    scale_fill_gradientn(colours = brewer.pal(9, "YlGnBu"),
                         name = "WIP %", n.breaks = 5, limits = c(0, 100)) +
     scale_shape_manual(name = "Geologic Age", 
                        values = c(20, 21, 22, 23, 24, 25),
                        labels= c("Pleistocene", "Quaternary", 
                                  "Miocene-Eocene", "Oligocene-Eocene",
                                  "Eocene", "pre-Tertiary" )) +
    geom_smooth(aes(y = (fitted(mod2.2)), x = log(carbon_stock_g_cm2)), 
                method = "lm", color = "#fa3e3e", fill = "#fa3e3e", 
                size = 1.2, linetype = 5, alpha = 0.3, se = T) +
    xlab(expression('Sampled SOC %'))+ #(MgC ha'^-1*')')) +  
    ylab(expression('Predicted SOC %'))+ #(MgC ha'^-1*')')) +
    geom_abline(intercept = 0, slope = 1, linewidth = 1, linetype = "dashed") +
    #xlim(-4, 5) +
    #ylim(-4, 5)  +
    guides(guide_legend(byrow = TRUE)) +
    theme(legend.position = 'right', 
          legend.key.size = unit(0.5, "cm"),
          panel.background = element_blank(),
          panel.grid.major = element_line(colour = "grey80"),
          axis.ticks = element_blank(),
          text = element_text(size = 18))

```

The `dredge` function can be used to look through mutliple combinations of models, but this may produce spurious results

```{r, cache=TRUE, echo=TRUE, results='hide', message=FALSE, warning=FALSE}
gmod <- lmer(log(carbon_stock_g_cm2) ~  WIP*Temp*Precip*MNDWI+GEOLOGIC_AGE+ (1+(depth_cm)|sample_ID), data = wa_dat_scale, REML = F, na.action = 'na.fail')
x <- dredge(gmod, beta = "sd" )
```

```{r, cache=TRUE, out.height="50%",results='hide',message=FALSE, warning=FALSE}
print(x, abbrev.names = F)
dmod <- get.models(x, 1)[[1]]
```

The dredge model `dmod` shows that the "best" model includes GEOLOGIC_AGE, Temp, and WIP

```{r }
summary(dmod)
```

Looks like there is a pretty good $R^2$ for the model but it's fairly complex and has lots of covariates

```{r tidy=FALSE}
r.sq(log(wa_dat_scale$carbon_stock_g_cm2), fitted(dmod))

library(RColorBrewer)
ggplot(wa_dat_scale, aes(y = (fitted(dmod)), x = log(carbon_stock_g_cm2))) +
    geom_jitter(color='black', 
               aes(fill = (wa_dat$WIP*100), shape = as.factor(GEOLOGIC_AGE)),
               size = 3, stroke = 0.9, alpha = 0.7) +
    scale_fill_gradientn(colours = brewer.pal(9, "YlGnBu"), 
                         name = "WIP %", n.breaks = 5, limits = c(0, 100)) +
     scale_shape_manual(name = "Geologic Age", 
                        values = c(20, 21, 22, 23, 24, 25),
                        labels= c("Pleistocene", "Quaternary", 
                                  "Miocene-Eocene", "Oligocene-Eocene",
                                  "Eocene", "pre-Tertiary" )) +
    geom_smooth(aes(y = (fitted(dmod)), x = log(carbon_stock_g_cm2)), 
                method = "lm", color = "#fa3e3e", fill = "#fa3e3e", 
                size = 1.2, linetype = 5, alpha = 0.3, se = T) +
    xlab(expression('Sampled SOC %'))+ #(MgC ha'^-1*')')) +  
    ylab(expression('Predicted SOC %'))+ #(MgC ha'^-1*')')) +
    geom_abline(intercept = 0, slope = 1, linewidth = 1, linetype = "dashed") +
    #xlim(-4, 5) +
    #ylim(-4, 5)  +
    guides(guide_legend(byrow = TRUE)) +
    theme(legend.position = 'right', 
          legend.key.size = unit(1.7, "cm"),
          panel.background = element_blank(),
          panel.grid.major = element_line(colour = "grey80"),
          axis.ticks = element_blank(),
          text = element_text(size = 18))
```

I also want to try Random Forest in order to see if there are non-linear relationships with SOC and other variables.

`depth_cm` is included as a predictor here in the data setup

```{r message=FALSE}
library(randomForest)
set.seed(11)

# Validation Set 
train.index <- as.vector(sample(c(1:nrow(wa_dat_scale)), 0.7*nrow(wa_dat_scale), replace=F))
train <- wa_dat_scale[train.index, c("carbon_stock_g_cm2", "WIP", "GEOLOGIC_AGE", "Temp", "Precip", "depth_cm", "NDVI", "MNDWI", "EVI", "NDYI", "Geomorphon_Class" )]
test <- wa_dat_scale[-train.index, c("carbon_stock_g_cm2", "WIP", "GEOLOGIC_AGE", "Temp", "Precip", "depth_cm", "NDVI", "MNDWI", "EVI", "NDYI", "Geomorphon_Class")]
full <- wa_dat[, c("carbon_stock_g_cm2", "WIP", "GEOLOGIC_AGE", "Temp", "Precip", "depth_cm", "NDVI", "MNDWI", "EVI", "NDYI",  "Geomorphon_Class")]

```

Only ~50% out of bag error. Looks like after depth `Precip`, `Temp`, `WIP`, and `NDYI` are the big drivers

-   `NDYI` is the normalized difference yellow index and might be related to water stressed vegetation in wetlands

```{r fig.show='hold', cache=TRUE}
rf_model <- randomForest(log(carbon_stock_g_cm2) ~ .,
                         ntree = 1000, mtry = 7,
                         importance = TRUE, data = full)


rf_model
plot(rf_model)
varImpPlot(rf_model)
```

```{r}
vip::vip(rf_model)
```


Look at partial dependency plots 
```{r}
randomForest::partialPlot(rf_model, full, WIP)
# randomForest::partialPlot(rf_model, full, Precip)
# randomForest::partialPlot(rf_model, full, Temp)
# randomForest::partialPlot(rf_model, full, NDYI)
# randomForest::partialPlot(rf_model, full, MNDWI)

#rf_model |> pdp::partial(pred.var = "Precip", train = full) |> autoplot(rug = T, train = full)
```


```{r fig.show='hold'}
rf.predtrain <- predict(rf_model, newdata = train)
rf.predtest <- predict(rf_model, newdata = test)
```

```{r "RF R2"}

paste0(round(mean((rf.predtrain - log(train$carbon_stock_g_cm2))^2), 3), " mean square error rf model from training")
paste0(round(r.sq(log(train$carbon_stock_g_cm2), rf.predtrain), 3), " R^2 rf model from training")
paste0(round(r.sq(log(test$carbon_stock_g_cm2), rf.predtest), 3),  " R^2 rf model from testing ")


rf.full <- predict(rf_model, newdata = wa_dat)
```

The random forest model $R^2$ is `r r.sq(log(wa_dat$carbon_stock_g_cm2), rf.full)` and the fit looks fairly good on a log-based plot

```{r fig.show='hold', tidy=FALSE}

library(RColorBrewer)
ggplot(wa_dat_scale, aes(y = (rf.full), x = log(carbon_stock_g_cm2))) +
    geom_jitter(color='black', 
               aes(fill = (wa_dat$WIP*100), shape = as.factor(GEOLOGIC_AGE)),
               size = 3, stroke = 0.9, alpha = 0.7) +
    scale_fill_gradientn(colours = brewer.pal(9, "YlGnBu"), 
                         name = "WIP %", n.breaks = 5, limits = c(0, 100)) +
    scale_shape_manual(name = "Geologic Age", 
                        values = c(20, 21, 22, 23, 24, 25),
                        labels= c("Pleistocene", "Quaternary", 
                                  "Miocene-Eocene", "Oligocene-Eocene",
                                  "Eocene", "pre-Tertiary" )) +
    geom_smooth(aes(y = (rf.full), x = log(carbon_stock_g_cm2)), 
                method = "lm", color = "#fa3e3e", fill = "#fa3e3e", 
                size = 1.2, linetype = 5, alpha = 0.3, se = T) +
    xlab(expression('Sampled SOC %'))+ #(MgC ha'^-1*')')) +  
    ylab(expression('Predicted SOC %'))+ #(MgC ha'^-1*')')) +
    geom_abline(intercept = 0, slope = 1, linewidth = 1, linetype = "dashed") +
    #xlim(-4, 5) +
    #ylim(-4, 5)  +
    guides(guide_legend(byrow = TRUE)) +
    theme(legend.position = 'right', 
          legend.key.size = unit(0.5, "cm"),
          panel.background = element_blank(),
          panel.grid.major = element_line(colour = "grey80"),
          axis.ticks = element_blank(),
          text = element_text(size = 18))
```

```{r eval=FALSE, echo=FALSE}
# nn <- nnet::nnet(log(carbon_stock_g_cm2) ~ ., data = full, size = 7, decay = 0.1,
#            linout = TRUE, trace = FALSE)
# p1 <- vip(nn, type = "garson")
# p1
```

